n <- dim(board)[1]
out <- matrix(0, n, n)
for (i in 1:n-1) {
out[i,] <- board[i,] + board[i+1,]
}
find_in_grid(out, look_for = 2)
}
fellow_mole_below(board)
document()
load_all()
document()
load_all()
load_all()
board
document()
load_all()
play(10)
new_board(10)
load_all()
new_board(10)
document()
load_all()
new_board(10)
load_all()
new_board(10)
play(15)
board <- new_board(10)
board
n <- dim(board)[1]
last_whack <- attr(board, "last_whack")
num_moles <- attr(board, "num_moles")
mole_locs <- mole_locations(board)
moles_below <- fellow_mole_below(board)
moles_right <- fellow_mole_right(board)
apply_mole_loc_borders <- function(g, args) {
g %>%
tab_style(
style = cell_borders(sides = "all",
color = "grey",
weight = px(1.5)),
locations = cells_body(rows = args[["row"]],
columns = args[["col"]]))
}
remove_mole_below_borders <- function(g, args) {
g %>%
tab_style(
style = cell_borders(sides = "bottom",
color = "transparent"),
locations = cells_body(rows = args[["row"]],
columns = args[["col"]]))
}
remove_mole_right_borders <- function(g, args) {
g %>%
tab_style(
style = cell_borders(sides = "right",
color = "transparent"),
locations = cells_body(rows = args[["row"]],
columns = args[["col"]]))
}
# generic output
out <- board %>%
# noquote() %>% # at this point, it's a matrix
as.data.frame() %>%
gt() %>%
tab_header(title = "Whack-A-Mole") %>%
tab_options(column_labels.hidden = TRUE,
table.width = pct(60)) %>%
cols_align(align = "center") %>%
tab_source_note(glue("Number of moles left: {num_moles}"))
out
if (is.null(last_whack)) {
# if no last whack, then we're looking at the initial board, and dont need to style cells
# do nothing
} else {
# the board has been whacked, we know there's an `adjacents` attributes for neighboring holes
adj_locs <- attr(board, "adjacents") %>%
# some of these adjacents might be outside the bounds of the grid, i.e. if the last whack was on an edge
# we should remove these
keep( function(z) (z[1] > 0 & z[1] <=n) & (z[2] > 0 & z[2] <= n) )
adj_params <- map(
adj_locs,
function(z) {
list(row = z[1],
column = z[2],
text_color = ifelse(board[z[1], z[2]] == 0, "darkgreen", "#800000"),
bg_color = ifelse(board[z[1], z[2]] == 0, "lightgreen", "#fadadd")
)
})
apply_adj_style <- function(g, args) {
g %>%
tab_style(
style = list(
cell_fill(color = args$bg_color),
cell_text(color = args$text_color)
),
locations = cells_body(rows = args$row,
columns = args$column))
}
out <- out %>%
tab_style(
style = list(
# cell_fill(color = "#fadadd"),
cell_text(weight = "bold"),
cell_fill(color = "lightgrey")
),
locations = cells_body(rows = last_whack[1],
columns = last_whack[2])
) %>%
{reduce(adj_params, apply_adj_style, .init = .)}
}
out %>%
# finally, add boarders around mole locations
{reduce(mole_locs, apply_mole_loc_borders, .init = .)} %>%
# then remove borders between connecting moles
{reduce(moles_below, remove_mole_below_borders, .init = .)} %>%
{reduce(moles_right, remove_mole_right_borders, .init = .)} %>%
print()
out %>%
# finally, add boarders around mole locations
{reduce(mole_locs, apply_mole_loc_borders, .init = .)}
out %>%
# finally, add boarders around mole locations
{reduce(mole_locs, apply_mole_loc_borders, .init = .)} %>%
# then remove borders between connecting moles
{reduce(moles_below, remove_mole_below_borders, .init = .)}
moles_below
rm(list = ls())
new_board(14)
load_all()
new_board(14)
load_all()
new_board(14)
load_all()
new_board(14)
load_all()
play(15)
load_all()
play(12)
play(12, turn_time = .3)
play(12, turn_time = .3)
play(12, turn_time = .3)
document()
load_all()
document()
load_all9
load_all()
document()
load_all()
play(10)
load_all()
play(10)
load_all()
play(10)
play(10)
board
board <- new_board(10)
board
i_star <- 5
n <- dim(board)[1]
n
(i:n - i_star)^2
(1:n - i_star)^2
(1:n - i_star)^2 # j's
j_star <- 6
(i_star, j_star)
i_star
c(i_star, j_star)
i_s <- matrix((1:n - i_star)^2, nrow = 1)
i_s
j_s <- matrix((1:n - j_star)^2, ncol = 1)
i_s %*% j_s
j_s %*% i_s
sqrt( i_s %*% j_s )
i_s <- matrix((1:n - i_star)^2, ncol = 1)
j_s <- matrix((1:n - j_star)^2, nrow = 1)
sqrt( i_s %*% j_s )
1 / sqrt( i_s %*% j_s )
sqrt( i_s %*% j_s )
out <- sqrt( i_s %*% j_s )
out / sum(out)
1 - (out / sum(out))
out <- i_s %*% j_s
1 - (out / sum(out))
out
out <- sqrt(i_s %*% j_s ) + 1
out
(out / sum(out))
1 / out
1 / out %>% round(digits = 1)
1 / out %>% round()
(1 / out )%>% round()
(1 / out )%>% round(digits = 2)
document()
load_all()
document()
load_all()
play(10)
document()
load_all()
play(11)
document()
load_all()
play(11)
board <- new_board(11)
board
#' Weight: how close to you to a certain point
close_to <- function(board,
i_star = ceiling(dim(board)[1]/2) ,
j_star = ceiling(dim(board)[1]/2)) {
n <- dim(board)[1]
i_s <- matrix((1:n - i_star)^2, ncol = 1)
j_s <- matrix((1:n - j_star)^2, nrow = 1)
out <- sqrt(i_s %*% j_s ) + 1
return( 1 / out )
}
close_to(board)
close_to(board) %>% round(digits = 2)
close_to(board) %>% round(digits = 1)
n <- dim(board)[1]
i_s <- matrix((1:n - i_star), ncol = 1)
j_s <- matrix((1:n - j_star), nrow = 1)
out <- sqrt(i_s %*% j_s ) + 1
n
i_s <- matrix((1:n - i_star), ncol = 1)
i_s
i_s <- matrix(abs(1:n - i_star), ncol = 1)
j_s <- matrix(abs(1:n - j_star), nrow = 1)
out <- sqrt(i_s %*% j_s ) + 1
out
i_s
j_s
n <- 5
center_coord <- (n + 1) / 2
center_coord
coord_vector <- seq(1, n) - center_coord
coord_vector
X <- outer(rep(1, n), coord_vector, FUN = "*")
X
Y <- outer(coord_vector, rep(1, n), FUN = "*")
Y
?outer
distance_matrix <- sqrt(X^2 + Y^2)
distance_matrix
out <- sqrt(X^2 + Y^2) + 1
1 / out
#' Weight: how close to you to a certain point
close_to <- function(board,
i_star = ceiling(dim(board)[1]/2) ,
j_star = ceiling(dim(board)[1]/2)) {
n <- dim(board)[1]
i_dists <- seq(1, n) - i_star
j_dists <- seq(1, n) - j_star
X <- outer(rep(1, n), i_dists, FUN = "*")
Y <- outer(j_dists, rep(1, n), FUN = "*")
out <- sqrt(X^2 + Y^2) + 1
return( 1 / out )
}
close_to(board)
close_to(board) %>% round(digits = 2)
close_to(board) %>% round(digits = 1)
close_to(board, 9, 9) %>% round(digits = 1)
close_to(board, 1, 1) %>% round(digits = 1)
document()
load_all()
load_all()
play(12)
document()
load_all()
play(12)
n <- 12
theta = .8
turn_time = 1
pref_radial = .05
pref_left = .05
pref_local = (1 - (pref_radial + pref_left)/2)
pref_global = (1 - (pref_radial + pref_left)/2)
# make sure n is an integer
if (!is.integer(n)) {
new_n <- as.integer(n)
cat(glue("# ---- `n` squashed from {n} to {new_n}"), "\n")
# just needed `new_n` for messaging, can go back to normal n name now
n <- new_n
}
# initialize a random matrix 4x4 matrix of zeros and 1s
board <- new_board(n = n, theta = theta)
moves <- 0
board
cat("# ------ Initial board ----- #", "\n")
print(board)
size <- sum(board)
cat(glue("# ------ # moles left: {size} ------ #"), "\n")
# trivially see if it's solved, if not continue
board_is_solved <- is_solved(board)
Sys.sleep(turn_time)
board_is_solved
# Initially, whack with strong preference for:
# ---- 1) centrality
# ---- 2) mole density
central <- close_to(board, i_star = ceiling(n/2), j_star = ceiling(n/2))
central
global <- density_global(board)
global
# leftward <- linear_left(board)
weight <- .5 * central + .5 * global
hit <- weight %>% which.max() %>% arrayInd(c(n, n)) # get location of highest weighted mole
hit
board <- whack(board, hit[1], hit[2]) # whack the mole
Sys.sleep(turn_time)
board_is_solved <- is_solved(board) # check if we've solved
moves <- moves + 1 # add a move
central <- close_to(board, i_star <- ceiling(n/2), j_star = ceiling(n/2))
near_last_hit <- close_to(board, i_star <- hit[1], j_star = hit[2])
global <- density_global(board)
weight <- .7 * global + .2 * central + .1 * near_last_hit
hit <- weight %>% which.max() %>% arrayInd(c(n, n)) # get location of first, largest subspace
board <- whack(board, hit[1], hit[2])
central
near_last_hit <- close_to(board, i_star <- hit[1], j_star = hit[2])
near_last_hit
global <- density_global(board)
global
weight <- .7 * global + .2 * central + .1 * near_last_hit
weight %>% round(digits = 1)
board
board
board <- new_board(11)
board
i_star = ceiling(dim(board)[1]/2)
j_star = ceiling(dim(board)[1]/2)
n <- dim(board)[1]
i_dists <- seq(1, n) - i_star
j_dists <- seq(1, n) - j_star
X <- outer(rep(1, n), i_dists, FUN = "*")
Y <- outer(j_dists, rep(1, n), FUN = "*")
out <- sqrt(X^2 + Y^2) + 1
out
out <- 1 / sqrt(X^2 + Y^2) + 1
out
# zero out weights where there are no moles
out %*% board
out
board
# zero out weights where there are no moles
board %*% out
board
attr(num_moles)
atributes(board)
attributes(board)
det(board)
det(new_board(19))
det(new_board(10))
det(new_board(11))
det(new_board(13))
solve(new_board(11))
solve(new_board(11))
solve(new_board(11))
solve(new_board(11))
solve(new_board(11))
solve(new_board(12))
det(new_board(12))
det(new_board(12))
det(new_board(12))
det(new_board(12))
det(new_board(12))
det(new_board(12))
det(new_board(12))
det(new_board(12))
det(new_board(4))
det(new_board(45))
det(new_board(43))
det(new_board(21))
det(new_board(12))
det(new_board(13))
det(new_board(14))
det(new_board(15))
det(new_board(15))
det(new_board(16))
det(new_board(16))
det(new_board(17))
det(new_board(17))
det(new_board(17))
det(new_board(17))
det(new_board(17))
# zero out weights where there are no moles
board * out
out
n <- dim(board)[1]
i_dists <- seq(1, n) - i_star
j_dists <- seq(1, n) - j_star
X <- outer(rep(1, n), i_dists, FUN = "*")
Y <- outer(j_dists, rep(1, n), FUN = "*")
out <- 1 / sqrt(X^2 + Y^2) + 1
out
out <- 1 / (sqrt(X^2 + Y^2) + 1)
out
# zero out weights where there are no moles
board * out
# zero out weights where there are no moles
board * out %>% round(digits = 1)
document()
load_all()
play(10)
load_all()
play(10)
load_all()
play()
play()
play(10)
load_all()
play(10)
board <- new_board(10)
board
board <- make_big(board)
board
density <- matrix(0, nrow = n, ncol = n)
board
n <- dim(board)[1]
n
density <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
for (j in 1:n) {
density[i, j] <- local_sum(board, i, j))
for (i in 1:n) {
for (j in 1:n) {
density[i, j] <- local_sum(board, i, j)
}
}
density <- matrix(0, nrow = n, ncol = n)
density
board
for (i in 2:n-1) {
for (j in 2:n-1) {
density[i, j] <- local_sum(board, i, j)
}
}
for (i in 2:(n-1)) {
for (j in 2:(n-1)) {
density[i, j] <- local_sum(board, i, j)
}
}
density
out <- density * board
out
out <-  strip_edges(out) %>%
{. / sum(.)}
out
out %>% round(digits = 1)
out %>% round(digits = 2)
out %>% round(digits = 3)
out <-  strip_edges(out)
out
board <- new_board(10)
greedy(board)
load_all
load_all()
document()
load_all()
document()
load_all()
play(11)
play(12)
document()
load_all()
play(10)
board <- new_board(11)
board
n <- dim(board)[1]
i_dists <- seq(1, n) - i_star
j_dists <- seq(1, n) - j_star
X <- outer(rep(1, n), i_dists, FUN = "*")
Y <- outer(j_dists, rep(1, n), FUN = "*")
out <- 1 / (sqrt(X^2 + Y^2) + 1)
out
out <- (sqrt(X^2 + Y^2) + 1)
out <- (sqrt(X^2 + Y^2) + 1)
out
out <- (X^2 + Y^2)
out
out <- log((X^2 + Y^2)
# zero out weights where there are no moles
return( board * out )
out <- log((X^2 + Y^2))
out
out <- (X^2 + Y^2)
out
out <- (X^2 + Y^2) * board
out
out / sum(out)
?lambda
j_star
document()
load_all()
load_all()
document()
load_all()
play(10)
load_all()
play()
attr(board, "num_moles")
sparsity <- attr(board, "num_moles") / (n*n)
sparsity
document()
load_all()
play(10)
play(10)
play(10)
play(20)
library(devtools())
library(devtools)
document()
load_all()
use_pkgdown_github_pages()
